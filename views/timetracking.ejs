<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Time Tracking</title>
  <link rel="stylesheet" href="/style.css">
</head>
<body>
  <h1>Time Tracking (Development)</h1>
  <button id="startTracking">Start Tracking</button>
  <button id="stopTracking" disabled>Stop Tracking</button>
  <button id="toggleVideo">Enable Video</button>
  <div id="timeDisplay">Time: 00:00:00</div>
  <video id="videoStream" autoplay></video>

  <script src="/script.js"></script>
  <script>
    document.addEventListener('DOMContentLoaded', () => {
      const startTrackingButton = document.getElementById('startTracking');
      const stopTrackingButton = document.getElementById('stopTracking');
      const toggleVideoButton = document.getElementById('toggleVideo');
      const videoStreamElement = document.getElementById('videoStream');
      const projectNameInput = 'Development Project'; // Default project name for testing
      const ws = new WebSocket('ws://localhost:3000');

      ws.onopen = () => {
        console.log('WebSocket connection opened');
      };

      ws.onerror = (error) => {
        console.error('WebSocket error:', error);
      };

      ws.onmessage = async event => {
        const data = JSON.parse(event.data);
        console.log('Received message:', data);

        if (data.type === 'videoStatus') {
          toggleVideoButton.innerText = data.isVideoEnabled ? 'Disable Video' : 'Enable Video';
        }
        if (data.type === 'timeUpdate') {
          updateTimeDisplay(data.elapsedTime);
        }
        if (data.type === 'offer') {
          await peerConnection.setRemoteDescription(new RTCSessionDescription(data.offer));
          const answer = await peerConnection.createAnswer();
          await peerConnection.setLocalDescription(answer);
          ws.send(JSON.stringify({ type: 'answer', answer: answer }));
        } else if (data.type === 'answer') {
          await peerConnection.setRemoteDescription(new RTCSessionDescription(data.answer));
        } else if (data.type === 'candidate') {
          if (data.candidate) {
            await peerConnection.addIceCandidate(new RTCIceCandidate(data.candidate));
          }
        }
      };

      startTrackingButton.addEventListener('click', () => {
        console.log('Start Tracking button clicked');
        if (startTrackingButton.innerText === 'Start Tracking') {
          startTracking(ws, projectNameInput);
        } else {
          stopTracking(ws);
        }
      });

      toggleVideoButton.addEventListener('click', () => {
        console.log('Toggle Video button clicked');
        toggleVideo(ws);
      });

      let startTime;
      let timerInterval;
      let localStream;
      let peerConnection;
      const config = {
        iceServers: [
          { urls: 'stun:stun.l.google.com:19302' }
        ]
      };

      function startTracking(ws, projectName) {
        console.log('Starting tracking for project:', projectName);
        fetch('/time/dev/start', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ projectName })
        })
        .then(response => response.json())
        .then(data => {
          if (data.success) {
            startTime = new Date(data.timeEntry.startTime);
            timerInterval = setInterval(updateTime, 1000);
            ws.send(JSON.stringify({ type: 'startTracking', startTime: startTime }));
            startTrackingButton.innerText = 'Stop Tracking';
            console.log('Tracking started:', startTime);
          } else {
            console.error('Error starting time tracking:', data.error);
          }
        })
        .catch(error => {
          console.error('Error starting time tracking:', error);
        });
      }

      function stopTracking(ws) {
        console.log('Stopping tracking');
        fetch('/time/dev/stop', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' }
        })
        .then(response => response.json())
        .then(data => {
          if (data.success) {
            clearInterval(timerInterval);
            updateTime();
            ws.send(JSON.stringify({ type: 'stopTracking', endTime: new Date() }));
            startTrackingButton.innerText = 'Start Tracking';
            console.log('Tracking stopped');
          } else {
            console.error('Error stopping time tracking:', data.error);
          }
        })
        .catch(error => {
          console.error('Error stopping time tracking:', error);
        });
      }

      async function toggleVideo(ws) {
        console.log('Toggling video');
        fetch('/toggle-video', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ isVideoEnabled: toggleVideoButton.innerText === 'Enable Video' })
        })
        .then(response => response.json())
        .then(data => {
          if (data.success) {
            const buttonLabel = data.isVideoEnabled ? 'Disable Video' : 'Enable Video';
            toggleVideoButton.innerText = buttonLabel;
            ws.send(JSON.stringify({ type: 'videoStatus', isVideoEnabled: data.isVideoEnabled }));
            if (data.isVideoEnabled) {
              startVideoStream(ws);
            } else {
              stopVideoStream();
            }
            console.log('Video toggled:', data.isVideoEnabled);
          } else {
            console.error('Error toggling video:', data.error);
          }
        })
        .catch(error => {
          console.error('Error toggling video:', error);
        });
      }

      function updateTime() {
        const currentTime = new Date();
        const elapsedTime = new Date(currentTime - startTime);

        const hours = String(elapsedTime.getUTCHours()).padStart(2, '0');
        const minutes = String(elapsedTime.getUTCMinutes()).padStart(2, '0');
        const seconds = String(elapsedTime.getUTCSeconds()).padStart(2, '0');

        document.getElementById('timeDisplay').innerText = `Time: ${hours}:${minutes}:${seconds}`;
        ws.send(JSON.stringify({ type: 'timeUpdate', elapsedTime: `${hours}:${minutes}:${seconds}` }));
      }

      async function startVideoStream(ws) {
        console.log('Starting video stream');
        try {
          localStream = await navigator.mediaDevices.getUserMedia({ video: true });
          videoStreamElement.srcObject = localStream;

          peerConnection = new RTCPeerConnection(config);
          localStream.getTracks().forEach(track => peerConnection.addTrack(track, localStream));

          peerConnection.onicecandidate = event => {
            if (event.candidate) {
              ws.send(JSON.stringify({ type: 'candidate', candidate: event.candidate }));
            }
          };

          peerConnection.ontrack = event => {
            videoStreamElement.srcObject = event.streams[0];
          };

          const offer = await peerConnection.createOffer();
          await peerConnection.setLocalDescription(offer);
          ws.send(JSON.stringify({ type: 'offer', offer: offer }));

        } catch (error) {
          console.error('Error accessing webcam:', error);
        }
      }

      function stopVideoStream() {
        console.log('Stopping video stream');
        if (localStream) {
          localStream.getTracks().forEach(track => track.stop());
          videoStreamElement.srcObject = null;
        }
        if (peerConnection) {
          peerConnection.close();
          peerConnection = null;
        }
      }

      function updateTimeDisplay(elapsedTime) {
        document.getElementById('timeDisplay').innerText = `Time: ${elapsedTime}`;
      }
    });
  </script>
</body>
</html>
